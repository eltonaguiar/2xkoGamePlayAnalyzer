<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2XKO Gameplay Analysis - Backup Player</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #00ff00;
            padding: 20px;
            min-height: 100vh;
        }
        
        .terminal-container {
            max-width: 1400px;
            margin: 0 auto;
            background: #000;
            border: 2px solid #00ff00;
            border-radius: 5px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .terminal-header {
            background: #00ff00;
            color: #000;
            padding: 15px;
            margin: -20px -20px 20px -20px;
            border-radius: 3px 3px 0 0;
            font-weight: bold;
            text-align: center;
        }
        
        .terminal-prompt {
            color: #00ff00;
            margin-bottom: 10px;
        }
        
        .command-line {
            display: flex;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .prompt-symbol {
            color: #00ff00;
            margin-right: 10px;
        }
        
        .command-input {
            background: transparent;
            border: none;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            outline: none;
            flex: 1;
        }
        
        .video-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(400px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .video-card {
            background: #0a0a0a;
            border: 1px solid #00ff00;
            border-radius: 5px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .video-card:hover {
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        .video-card.active {
            border-color: #ffff00;
            background: #1a1a0a;
        }
        
        .video-title {
            color: #00ff00;
            font-weight: bold;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .video-info {
            color: #00ffff;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        .video-display-area {
            width: 100%;
            height: 300px;
            background: #000;
            border: 1px solid #00ff00;
            margin: 20px 0;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .video-display-area video,
        .video-display-area canvas,
        .video-display-area img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .controls-panel {
            background: #0a0a0a;
            border: 1px solid #00ff00;
            padding: 15px;
            margin-top: 20px;
            border-radius: 5px;
        }
        
        .control-button {
            background: #00ff00;
            color: #000;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            border-radius: 3px;
            transition: all 0.3s;
        }
        
        .control-button:hover {
            background: #00ffff;
            transform: scale(1.05);
        }
        
        .control-button:active {
            background: #ffff00;
        }
        
        .status-line {
            color: #00ff00;
            font-size: 12px;
            margin-top: 10px;
            padding: 10px;
            background: #0a0a0a;
            border-left: 3px solid #00ff00;
        }
        
        .error-line {
            color: #ff0000;
            background: #1a0a0a;
            border-left-color: #ff0000;
        }
        
        .success-line {
            color: #00ff00;
            background: #0a1a0a;
            border-left-color: #00ff00;
        }
        
        .gif-preview {
            max-width: 200px;
            max-height: 150px;
            border: 1px solid #00ff00;
            margin: 10px;
        }
        
        .loading-spinner {
            border: 3px solid #0a0a0a;
            border-top: 3px solid #00ff00;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat-box {
            background: #0a0a0a;
            border: 1px solid #00ff00;
            padding: 10px;
            border-radius: 3px;
        }
        
        .stat-label {
            color: #00ffff;
            font-size: 11px;
        }
        
        .stat-value {
            color: #00ff00;
            font-size: 18px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <div class="terminal-header">
            ‚ö° 2XKO GAMEPLAY ANALYZER - BACKUP MODE ‚ö°
        </div>
        
        <div class="command-line">
            <span class="prompt-symbol">$></span>
            <input type="text" class="command-input" id="commandInput" placeholder="Type 'help' for commands or click a clip to play" autocomplete="off">
        </div>
        
        <div class="status-line" id="statusLine">
            System ready. Loading clips...
        </div>
        
        <div class="video-display-area" id="videoDisplay">
            <div style="color: #00ff00; text-align: center;">
                <div class="loading-spinner"></div>
                <div>No video selected</div>
            </div>
        </div>
        
        <div class="controls-panel">
            <button class="control-button" onclick="playSelected()">‚ñ∂ PLAY</button>
            <button class="control-button" onclick="pauseVideo()">‚è∏ PAUSE</button>
            <button class="control-button" onclick="stopVideo()">‚èπ STOP</button>
            <button class="control-button" onclick="toggleLoop()">üîÅ LOOP</button>
            <button class="control-button" onclick="toggleSlowMo()">‚è± SLOW-MO</button>
            <button class="control-button" onclick="generateGIF()">üé¨ GIF</button>
            <button class="control-button" onclick="resetView()">üîÑ RESET</button>
        </div>
        
        <div class="stats-panel" id="statsPanel"></div>
        
        <div class="video-grid" id="videoGrid"></div>
    </div>
    
    <script>
        // Completely different approach - using object-oriented pattern with class
        class BackupVideoPlayer {
            constructor() {
                this.clips = [];
                this.currentClip = null;
                this.videoElement = null;
                this.canvasElement = null;
                this.isLooping = false;
                this.isSlowMo = false;
                this.playbackRate = 1.0;
                this.ctx = null;
                this.animationFrame = null;
                this.gifFrames = [];
                this.init();
            }
            
            init() {
                this.setupCommandHandler();
                this.updateStatus('System initializing...', 'success');
                // Load clips asynchronously
                this.loadClips().catch(e => {
                    this.updateStatus(`Failed to load clips: ${e.message}`, 'error');
                });
            }
            
            async loadClips() {
                // Try to load from metadata.json first, then fallback to hardcoded
                try {
                    const response = await fetch('metadata.json');
                    if (response.ok) {
                        const data = await response.json();
                        if (data.clips && Array.isArray(data.clips)) {
                            this.clips = data.clips.map(clip => ({
                                ...clip,
                                path: (clip.path || '').replace(/\\/g, '/')
                            }));
                            this.renderClips();
                            this.updateStatus(`Loaded ${this.clips.length} clips from metadata.json`, 'success');
                            return;
                        }
                    }
                } catch (e) {
                    console.log('Could not load from metadata.json, using fallback:', e);
                }
                
                // Fallback to hardcoded clips
                try {
                    const clipsData = [{"id": "mistake_unknown_0", "path": "clips/mistake_unknown_0.mp4", "start_time": 77.46666666666667, "end_time": 83.46666666666667, "player": "unknown", "mistake_type": "unsafe_special", "description": "player1 used Rocket Grab (5S1) which can be easily punished on whiff", "suggestion": "Rocket Grab is risky in neutral. Consider using it after conditioning opponent or with assist cover. Consider using at mid-range (not point-blank)", "damage_dealt": 274, "damage_taken": 185, "player_name": "Player 1", "range_suggestion": "Consider using at mid-range (not point-blank)", "round": 1, "leader": "player1"}, {"id": "mistake_unknown_1", "path": "clips/mistake_unknown_1.mp4", "start_time": 38.2, "end_time": 44.2, "player": "unknown", "mistake_type": "unsafe_special", "description": "player2 used Rocket Grab (5S1) which can be easily punished on whiff", "suggestion": "Rocket Grab is risky in neutral. Consider using it after conditioning opponent or with assist cover. Consider using at mid-range (not point-blank)", "damage_dealt": 135, "damage_taken": 226, "player_name": "Player 2", "range_suggestion": "Consider using at mid-range (not point-blank)", "round": 1, "leader": "player1"}];
                    
                    this.clips = clipsData.map(clip => ({
                        ...clip,
                        path: clip.path.replace(/\\/g, '/')
                    }));
                    
                    this.renderClips();
                    this.updateStatus(`Loaded ${this.clips.length} clips (fallback mode)`, 'success');
                } catch (e) {
                    this.updateStatus(`Error loading clips: ${e.message}`, 'error');
                }
            }
            
            renderClips() {
                const grid = document.getElementById('videoGrid');
                if (!grid) return;
                
                grid.innerHTML = '';
                
                this.clips.forEach((clip, index) => {
                    const card = document.createElement('div');
                    card.className = 'video-card';
                    card.onclick = () => this.selectClip(clip, index);
                    
                    const time = this.formatTime(clip.start_time);
                    const duration = (clip.end_time - clip.start_time).toFixed(1);
                    
                    card.innerHTML = `
                        <div class="video-title">[${index}] ${clip.player_name || 'Unknown'}</div>
                        <div class="video-info">Time: ${time} | Duration: ${duration}s</div>
                        <div class="video-info">Type: ${clip.mistake_type}</div>
                        <div class="video-info" style="color: #ffff00;">${clip.description}</div>
                        ${clip.damage_dealt ? `<div class="video-info">Damage: +${clip.damage_dealt} / -${clip.damage_taken}</div>` : ''}
                    `;
                    
                    grid.appendChild(card);
                });
                
                this.updateStats();
            }
            
            selectClip(clip, index) {
                // Remove active class from all cards
                document.querySelectorAll('.video-card').forEach(c => c.classList.remove('active'));
                // Add active class to selected card
                const cards = document.querySelectorAll('.video-card');
                if (cards[index]) cards[index].classList.add('active');
                
                this.currentClip = clip;
                this.loadVideo(clip.path);
                this.updateStatus(`Selected: ${clip.player_name} - ${clip.mistake_type}`, 'success');
            }
            
            loadVideo(path) {
                const display = document.getElementById('videoDisplay');
                if (!display) return;
                
                // Clear previous content
                display.innerHTML = '';
                
                // Try multiple approaches
                this.tryVideoElement(display, path);
            }
            
            tryVideoElement(container, path) {
                // Approach 1: Simple video element
                const video = document.createElement('video');
                video.controls = true;
                video.style.width = '100%';
                video.style.height = '100%';
                video.style.objectFit = 'contain';
                
                video.src = path;
                video.preload = 'metadata';
                
                video.onloadedmetadata = () => {
                    this.updateStatus(`Video loaded: ${video.duration.toFixed(2)}s`, 'success');
                    this.videoElement = video;
                };
                
                video.onerror = (e) => {
                    this.updateStatus(`Video element failed, trying canvas approach...`, 'error');
                    this.tryCanvasApproach(container, path);
                };
                
                video.oncanplay = () => {
                    this.updateStatus('Video ready to play', 'success');
                };
                
                container.appendChild(video);
                
                // Also try canvas as backup
                setTimeout(() => {
                    if (video.error) {
                        this.tryCanvasApproach(container, path);
                    }
                }, 2000);
            }
            
            tryCanvasApproach(container, path) {
                // Approach 2: Canvas-based rendering
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 600;
                canvas.style.border = '1px solid #00ff00';
                
                const ctx = canvas.getContext('2d');
                this.ctx = ctx;
                this.canvasElement = canvas;
                
                const video = document.createElement('video');
                video.crossOrigin = 'anonymous';
                video.src = path;
                video.muted = true; // Required for autoplay in some browsers
                
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth || 800;
                    canvas.height = video.videoHeight || 600;
                    this.updateStatus('Canvas video loaded', 'success');
                };
                
                video.onplay = () => {
                    this.drawVideoFrame(video, ctx, canvas);
                };
                
                video.onerror = () => {
                    this.updateStatus('All video methods failed. Video may need re-encoding.', 'error');
                    container.innerHTML = `
                        <div style="color: #ff0000; text-align: center; padding: 20px;">
                            <div>‚ö† Video playback failed</div>
                            <div style="margin-top: 10px; font-size: 12px;">
                                File: ${path}<br>
                                Try: <a href="${path}" target="_blank" style="color: #00ffff;">Open directly</a>
                            </div>
                        </div>
                    `;
                };
                
                container.appendChild(canvas);
                container.appendChild(video);
                video.style.display = 'none';
                this.videoElement = video;
            }
            
            drawVideoFrame(video, ctx, canvas) {
                if (video.paused || video.ended) return;
                
                ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                
                // Draw overlay info
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(10, 10, 300, 80);
                ctx.fillStyle = '#00ff00';
                ctx.font = '14px monospace';
                ctx.fillText(`Time: ${video.currentTime.toFixed(2)}s`, 20, 35);
                ctx.fillText(`Duration: ${video.duration.toFixed(2)}s`, 20, 55);
                if (this.currentClip) {
                    ctx.fillText(this.currentClip.player_name, 20, 75);
                }
                
                this.animationFrame = requestAnimationFrame(() => this.drawVideoFrame(video, ctx, canvas));
            }
            
            playSelected() {
                if (this.videoElement) {
                    this.videoElement.playbackRate = this.isSlowMo ? 0.5 : 1.0;
                    this.videoElement.play().catch(e => {
                        this.updateStatus(`Play error: ${e.message}`, 'error');
                    });
                }
            }
            
            pauseVideo() {
                if (this.videoElement) {
                    this.videoElement.pause();
                }
            }
            
            stopVideo() {
                if (this.videoElement) {
                    this.videoElement.pause();
                    this.videoElement.currentTime = 0;
                    if (this.animationFrame) {
                        cancelAnimationFrame(this.animationFrame);
                    }
                }
            }
            
            toggleLoop() {
                this.isLooping = !this.isLooping;
                if (this.videoElement) {
                    this.videoElement.loop = this.isLooping;
                }
                this.updateStatus(`Loop: ${this.isLooping ? 'ON' : 'OFF'}`, this.isLooping ? 'success' : '');
            }
            
            toggleSlowMo() {
                this.isSlowMo = !this.isSlowMo;
                if (this.videoElement) {
                    this.videoElement.playbackRate = this.isSlowMo ? 0.5 : 1.0;
                }
                this.updateStatus(`Slow-mo: ${this.isSlowMo ? 'ON' : 'OFF'}`, this.isSlowMo ? 'success' : '');
            }
            
            generateGIF() {
                if (!this.videoElement || !this.canvasElement) {
                    this.updateStatus('GIF generation requires canvas mode', 'error');
                    return;
                }
                
                this.updateStatus('Generating GIF frames... (This may take a moment)', '');
                this.gifFrames = [];
                const video = this.videoElement;
                const canvas = this.canvasElement;
                const ctx = this.ctx;
                const originalTime = video.currentTime;
                
                video.currentTime = 0;
                video.pause();
                
                const captureFrame = () => {
                    if (video.readyState >= 2) {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        this.gifFrames.push(canvas.toDataURL('image/png'));
                        
                        video.currentTime += 0.1; // Capture every 0.1 seconds
                        
                        if (video.currentTime < Math.min(video.duration, 3.0)) {
                            setTimeout(captureFrame, 100);
                        } else {
                            this.displayGIF();
                            video.currentTime = originalTime;
                        }
                    } else {
                        setTimeout(captureFrame, 100);
                    }
                };
                
                captureFrame();
            }
            
            displayGIF() {
                const display = document.getElementById('videoDisplay');
                if (!display) return;
                
                display.innerHTML = '<div style="color: #00ff00;">GIF Preview (first frame):</div>';
                this.gifFrames.slice(0, 10).forEach((frame, i) => {
                    const img = document.createElement('img');
                    img.src = frame;
                    img.className = 'gif-preview';
                    display.appendChild(img);
                });
                
                this.updateStatus(`Captured ${this.gifFrames.length} frames. Right-click images to save.`, 'success');
            }
            
            resetView() {
                const display = document.getElementById('videoDisplay');
                if (display && this.currentClip) {
                    this.loadVideo(this.currentClip.path);
                }
            }
            
            setupCommandHandler() {
                const input = document.getElementById('commandInput');
                if (!input) return;
                
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        const cmd = input.value.trim().toLowerCase();
                        input.value = '';
                        this.executeCommand(cmd);
                    }
                });
            }
            
            executeCommand(cmd) {
                const parts = cmd.split(' ');
                const command = parts[0];
                
                switch(command) {
                    case 'help':
                        this.updateStatus('Commands: play, pause, stop, loop, slowmo, gif, reset, list, select [index]', 'success');
                        break;
                    case 'play':
                        this.playSelected();
                        break;
                    case 'pause':
                        this.pauseVideo();
                        break;
                    case 'stop':
                        this.stopVideo();
                        break;
                    case 'loop':
                        this.toggleLoop();
                        break;
                    case 'slowmo':
                        this.toggleSlowMo();
                        break;
                    case 'gif':
                        this.generateGIF();
                        break;
                    case 'reset':
                        this.resetView();
                        break;
                    case 'list':
                        this.updateStatus(`Available clips: ${this.clips.map((c, i) => `[${i}] ${c.player_name}`).join(', ')}`, 'success');
                        break;
                    case 'select':
                        const index = parseInt(parts[1]);
                        if (!isNaN(index) && index >= 0 && index < this.clips.length) {
                            this.selectClip(this.clips[index], index);
                        } else {
                            this.updateStatus('Invalid clip index', 'error');
                        }
                        break;
                    default:
                        this.updateStatus(`Unknown command: ${command}. Type 'help' for commands.`, 'error');
                }
            }
            
            updateStatus(message, type = '') {
                const statusLine = document.getElementById('statusLine');
                if (statusLine) {
                    statusLine.textContent = `> ${message}`;
                    statusLine.className = 'status-line' + (type === 'error' ? ' error-line' : type === 'success' ? ' success-line' : '');
                }
                console.log(`[BackupPlayer] ${message}`);
            }
            
            updateStats() {
                const panel = document.getElementById('statsPanel');
                if (!panel) return;
                
                const totalClips = this.clips.length;
                const totalDamage = this.clips.reduce((sum, c) => sum + (c.damage_dealt || 0), 0);
                const player1Clips = this.clips.filter(c => c.player === 'player1' || c.player_name === 'Player 1').length;
                const player2Clips = this.clips.filter(c => c.player === 'player2' || c.player_name === 'Player 2').length;
                
                panel.innerHTML = `
                    <div class="stat-box">
                        <div class="stat-label">Total Clips</div>
                        <div class="stat-value">${totalClips}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Player 1 Mistakes</div>
                        <div class="stat-value">${player1Clips}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Player 2 Mistakes</div>
                        <div class="stat-value">${player2Clips}</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-label">Total Damage</div>
                        <div class="stat-value">${totalDamage}</div>
                    </div>
                `;
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
        }
        
        // Global functions for button onclick handlers
        let playerInstance = null;
        
        function playSelected() {
            if (playerInstance) playerInstance.playSelected();
        }
        
        function pauseVideo() {
            if (playerInstance) playerInstance.pauseVideo();
        }
        
        function stopVideo() {
            if (playerInstance) playerInstance.stopVideo();
        }
        
        function toggleLoop() {
            if (playerInstance) playerInstance.toggleLoop();
        }
        
        function toggleSlowMo() {
            if (playerInstance) playerInstance.toggleSlowMo();
        }
        
        function generateGIF() {
            if (playerInstance) playerInstance.generateGIF();
        }
        
        function resetView() {
            if (playerInstance) playerInstance.resetView();
        }
        
        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                try {
                    playerInstance = new BackupVideoPlayer();
                } catch (e) {
                    console.error('Failed to initialize backup player:', e);
                    document.getElementById('statusLine').textContent = `> ERROR: ${e.message}`;
                    document.getElementById('statusLine').className = 'status-line error-line';
                }
            });
        } else {
            try {
                playerInstance = new BackupVideoPlayer();
            } catch (e) {
                console.error('Failed to initialize backup player:', e);
                document.getElementById('statusLine').textContent = `> ERROR: ${e.message}`;
                document.getElementById('statusLine').className = 'status-line error-line';
            }
        }
        
        // Global error handler
        window.addEventListener('error', (e) => {
            console.error('Global error:', e.error);
            if (document.getElementById('statusLine')) {
                document.getElementById('statusLine').textContent = `> ERROR: ${e.error?.message || 'Unknown error'}`;
                document.getElementById('statusLine').className = 'status-line error-line';
            }
        });
        
        window.addEventListener('unhandledrejection', (e) => {
            console.error('Unhandled rejection:', e.reason);
        });
    </script>
</body>
</html>
